<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>STX B+ Tree Template Classes: stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">STX B+ Tree Template Classes
   &#160;<span id="projectnumber">0.9</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00036.html">stx</a>      </li>
      <li class="navelem"><a class="el" href="a00006.html">btree_multiset</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="stx::btree_multiset" -->
<p>Specialized B+ tree template class implementing STL's multiset container.  
 <a href="a00006.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00032_source.html">btree_multiset.h</a>&gt;</code></p>

<p><a href="a00056.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">empty_struct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty struct used as a placeholder for the data_type.  <a href="a00014.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">First template parameter: The key type of the btree.  <a href="#adaf86bdcdf48a7d4ed87ae020436287e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Second template parameter: Key comparison function object.  <a href="#ab4d81bc53597e88abe6617421837df21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Third template parameter: Traits object used to define more parameters of the B+ tree.  <a href="#adf34a1c10a3b0e0c1caa0358b9d4f059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourth template parameter: STL allocator.  <a href="#a3bd75b696bde37ad47838d8058503799"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00014.html">empty_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a4797d9899509ebbd391f6478f85fefd9">data_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty data_type.  <a href="#a4797d9899509ebbd391f6478f85fefd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a5fe61553bb02818305fde84b5342e753">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the set value_type: the key_type.  <a href="#a5fe61553bb02818305fde84b5342e753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00006.html">btree_multiset</a><br class="typebreak"/>
&lt; <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <br class="typebreak"/>
<a class="el" href="a00006.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of our own type.  <a href="#a99552060748673aa8a60e7d663f8f4a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00001.html">stx::btree</a>&lt; <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <br class="typebreak"/>
<a class="el" href="a00006.html#a4797d9899509ebbd391f6478f85fefd9">data_type</a>, <a class="el" href="a00006.html#a5fe61553bb02818305fde84b5342e753">value_type</a>, <br class="typebreak"/>
<a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <a class="el" href="a00006.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, true, <br class="typebreak"/>
<a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8dd7ea83ed8beaba51c5578b1283e306">btree_impl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation type of the btree_base.  <a href="#a8dd7ea83ed8beaba51c5578b1283e306"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function class comparing two value_type keys.  <a href="#a7ef41640ce62bdd8b1857ae6c3ef1c51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00001.html#aa692f5303dd2c4fee4958cbbfc3db5da">btree_impl::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type used to count keys.  <a href="#acb308af84d816e44d6fcaaf075b08a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::tree_stats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Small structure containing statistics about the tree.  <a href="#a268704f56c398ed05b600262f8c1d558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like iterator object for B+ tree items.  <a href="#a0d0c6764234271152a77643d5f160889"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like iterator object for B+ tree items.  <a href="#ac3b6e263ec2f54cab4e541b02e2156bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
btree_impl::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create mutable reverse iterator by using STL magic  <a href="#aa20cfd7ed6236bc3c51b20d5a77a5286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
btree_impl::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create constant reverse iterator by using STL magic  <a href="#aa137474f07b11232834fc838c96f89b4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ae51979526a758ca48dff71269509d30d">btree_multiset</a> (const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializing an empty B+ tree with the standard key comparison function.  <a href="#ae51979526a758ca48dff71269509d30d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a4411a079d52cdac10490c9f44827ed63">btree_multiset</a> (const <a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;kcf, const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing an empty B+ tree with a special key comparison object.  <a href="#a4411a079d52cdac10490c9f44827ed63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00006.html#a6dcabc7e14031cfe33c2e476b1c42e0b">btree_multiset</a> (InputIterator first, InputIterator last, const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last)  <a href="#a6dcabc7e14031cfe33c2e476b1c42e0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00006.html#a850ad8cd4782cf8dd11ef9ec7660dbf1">btree_multiset</a> (InputIterator first, InputIterator last, const <a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;kcf, const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last) and a special key comparison object.  <a href="#a850ad8cd4782cf8dd11ef9ec7660dbf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aec3bb61dacff05a504ae53889d8e3bf3">~btree_multiset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up all used B+ tree memory pages.  <a href="#aec3bb61dacff05a504ae53889d8e3bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aad820bbc85b7beaaca43fbdb1b610b56">swap</a> (<a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast swapping of two identical B+ tree objects.  <a href="#aad820bbc85b7beaaca43fbdb1b610b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a3ecbf097192ab41b7a29db4349ce2d3e">key_comp</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to the key comparison object sorting the B+ tree.  <a href="#a3ecbf097192ab41b7a29db4349ce2d3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a84f47ce04fb5330cb2d766a105b278a2">value_comp</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to a constructed value_type comparison object.  <a href="#a84f47ce04fb5330cb2d766a105b278a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ac2fc089101a5d6fdf86ee2d09b9eacce">get_allocator</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base node allocator provided during construction.  <a href="#ac2fc089101a5d6fdf86ee2d09b9eacce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a77cc7f5486c5add7feb4c9e601c4d921">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all keys and all nodes of the tree.  <a href="#a77cc7f5486c5add7feb4c9e601c4d921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0c8b01c05f01540fe8e7c87f7e798557">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#a0c8b01c05f01540fe8e7c87f7e798557"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#a3b3fdd20ed1c32051e6e8e9762789178"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#acca702924e73cc5df9f8e27f59259f7c">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only constant iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#acca702924e73cc5df9f8e27f59259f7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8fa9d5230ddb6f9306b2e941c1448ece">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only constant iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#a8fa9d5230ddb6f9306b2e941c1448ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ad5ff92256da155cf0a800c0be6d37f10">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write reverse iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#ad5ff92256da155cf0a800c0be6d37f10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#accb388873e7a00b1779a27487e4c0200">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write reverse iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#accb388873e7a00b1779a27487e4c0200"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aab7bf40d95f5e2e3a6f48ff132e5aa5c">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only reverse iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#aab7bf40d95f5e2e3a6f48ff132e5aa5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a01090ac817bc6525160dbee3b2943ad1">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only reverse iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#a01090ac817bc6525160dbee3b2943ad1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9be405a164ded347358ce38599d768bd">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of keys in the B+ tree.  <a href="#a9be405a164ded347358ce38599d768bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1943f3a2270fd9a13deb4d98855eb4bc">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is at least one key in the B+ tree.  <a href="#a1943f3a2270fd9a13deb4d98855eb4bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a2b0012b20d4bc04d78d1297d78550d8a">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest possible size of the B+ Tree.  <a href="#a2b0012b20d4bc04d78d1297d78550d8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00006.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a926c5bb8fbf409b1371c1ca211ba2bde">get_stats</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the current statistics.  <a href="#a926c5bb8fbf409b1371c1ca211ba2bde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1438934e738862154bbcfa1314b485bb">exists</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-STL function checking whether a key is in the B+ tree.  <a href="#a1438934e738862154bbcfa1314b485bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a130a3b87e39b1d9ff8be6df80b942737">find</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an iterator to the key slot if found.  <a href="#a130a3b87e39b1d9ff8be6df80b942737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ac3bf82364b3392aa056b866a012ac0d8">find</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an constant iterator to the key slot if found.  <a href="#ac3bf82364b3392aa056b866a012ac0d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ab2ae64a7de25306d48798d502de46b6c">count</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns the number of identical key entries found.  <a href="#ab2ae64a7de25306d48798d502de46b6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#acf1949d71f9c83184c98d084d66c56a4">lower_bound</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns an iterator to the first pair equal to or greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller.  <a href="#acf1949d71f9c83184c98d084d66c56a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#afb5c018e2dd2c9f53a148ddf0781921d">lower_bound</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns a constant iterator to the first pair equal to or greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller.  <a href="#afb5c018e2dd2c9f53a148ddf0781921d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a5e1197bbc27c927ebe4087541d601f20">upper_bound</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns an iterator to the first pair greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal.  <a href="#a5e1197bbc27c927ebe4087541d601f20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a5833bec011824d4b54b716b685ae74ca">upper_bound</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns a constant iterator to the first pair greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal.  <a href="#a5833bec011824d4b54b716b685ae74ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>, <a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a405388c6589746b4a01af6ab8a4b4321">equal_range</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="a00006.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00006.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>.  <a href="#a405388c6589746b4a01af6ab8a4b4321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aeffb8c7205996ac1a5ac40976f47a96f">equal_range</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="a00006.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00006.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>.  <a href="#aeffb8c7205996ac1a5ac40976f47a96f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8151cc2608a7a0634d5a94e3824f8e34">operator==</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality relation of B+ trees of the same type.  <a href="#a8151cc2608a7a0634d5a94e3824f8e34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ae9ad03cbc3be10a4a972b06ec9abedec">operator!=</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality relation. Based on operator==.  <a href="#ae9ad03cbc3be10a4a972b06ec9abedec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a2dcdf9bb9c5e2eea56e9308388b07349">operator&lt;</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering relation of B+ trees of the same type.  <a href="#a2dcdf9bb9c5e2eea56e9308388b07349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a7c85cec4d55431ea5e057602ba8fe5a0">operator&gt;</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater relation. Based on operator&lt;.  <a href="#a7c85cec4d55431ea5e057602ba8fe5a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a35de24d784f61ae794c1fa56fa9c6673">operator&lt;=</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-equal relation. Based on operator&lt;.  <a href="#a35de24d784f61ae794c1fa56fa9c6673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a603b031718fb9bb00d0edefc58d560c3">operator&gt;=</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-equal relation. Based on operator&lt;.  <a href="#a603b031718fb9bb00d0edefc58d560c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a3e8081765077002a2cbc04e20506f03d">operator=</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">*** Fast Copy: Assign Operator and Copy Constructors  <a href="#a3e8081765077002a2cbc04e20506f03d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a988a8fc330955bc3e74976865c841904">btree_multiset</a> (const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a988a8fc330955bc3e74976865c841904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ad35b00f9ff7f148dbb5cfee7ac8102af">insert</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert a key into the B+ tree.  <a href="#ad35b00f9ff7f148dbb5cfee7ac8102af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0075140c2d21fe08b68f00e16630cff1">insert</a> (<a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> hint, const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert a key into the B+ tree.  <a href="#a0075140c2d21fe08b68f00e16630cff1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00006.html#a75db73a6c739f8515ab508d3241feb88">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert the range [first,last) of key_type into the B+ tree.  <a href="#a75db73a6c739f8515ab508d3241feb88"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00006.html#ac0ce2f8dad3a95fe6c276437abdacbc1">bulk_load</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk load a sorted range [first,last).  <a href="#ac0ce2f8dad3a95fe6c276437abdacbc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa4e4cd44265e4c5fb8617ca3d17dd843">erase_one</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases one (the first) entry of the given key.  <a href="#aa4e4cd44265e4c5fb8617ca3d17dd843"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#afe2a42873c3a97234668e2feabc5191d">erase</a> (const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all the entries of the given key.  <a href="#afe2a42873c3a97234668e2feabc5191d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ac174897bad297d88927e6abe4056a3b8">erase</a> (<a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the key/data pair referenced by the iterator.  <a href="#ac174897bad297d88927e6abe4056a3b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa5c867534e27a06c07baa2c17fbccfd1">erase</a> (<a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>, <a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all keys in the range [first,last).  <a href="#aa5c867534e27a06c07baa2c17fbccfd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6aaf291909c709ea33419940352288b3">print</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the B+ tree structure with keys onto the given ostream.  <a href="#a6aaf291909c709ea33419940352288b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8818ff27dd8b2275d4b6a68d728c6d77">print_leaves</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out only the leaves via the double linked list.  <a href="#a8818ff27dd8b2275d4b6a68d728c6d77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a862c504ed632b8591756c45273087e5a">verify</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a thorough verification of all B+ tree invariants.  <a href="#a862c504ed632b8591756c45273087e5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#af443508ecb8fd77f32f01709f2f9d666">dump</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the B+ tree out onto an ostream as a binary image.  <a href="#af443508ecb8fd77f32f01709f2f9d666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a7f6dd7739f76cf5d1a31507ca3d80197">restore</a> (std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a binary image of a dumped B+ tree from an istream.  <a href="#a7f6dd7739f76cf5d1a31507ca3d80197"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ad3e346ec9ff913e6b17857f7de7fa6f0">leafslotmax</a> = <a class="el" href="a00001.html#ac6c274f39fce8e14f6a881fc1da39cf8">btree_impl::leafslotmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base B+ tree parameter: The number of key/data slots in each leaf.  <a href="#ad3e346ec9ff913e6b17857f7de7fa6f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a291d8f653427c2dac2870ddd1e93a326">innerslotmax</a> = <a class="el" href="a00001.html#a78ae296638b9d6961f9101ddf45bf3e0">btree_impl::innerslotmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base B+ tree parameter: The number of key slots in each inner node, this can differ from slots in each leaf.  <a href="#a291d8f653427c2dac2870ddd1e93a326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a52ff2314ff166b6aec7ad572d37291cf">minleafslots</a> = <a class="el" href="a00001.html#ad8525611bf3b079ca4ab13dbab9b23c0">btree_impl::minleafslots</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key slots used in a leaf.  <a href="#a52ff2314ff166b6aec7ad572d37291cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a568261850e92855ce6dd296e969cf12d">mininnerslots</a> = <a class="el" href="a00001.html#aefbcc95b60d5bae8dd7ba9c25e5b6654">btree_impl::mininnerslots</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key slots used in an inner node.  <a href="#a568261850e92855ce6dd296e969cf12d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ad58d175cab81f7f1947cdc54547fbf85">selfverify</a> = <a class="el" href="a00001.html#a598601fa16cfb97b8b60a4eae6bde5ae">btree_impl::selfverify</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation.  <a href="#ad58d175cab81f7f1947cdc54547fbf85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1f660e9d76a8bc2d8afa950dec6f8fda">debug</a> = <a class="el" href="a00001.html#a224f31a88d50490e14f0f291d70ef2fc">btree_impl::debug</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug parameter: Prints out lots of debug information about how the algorithms change the tree.  <a href="#a1f660e9d76a8bc2d8afa950dec6f8fda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a2a11e2ee03e9bb4cb206826de0b135b2">allow_duplicates</a> = <a class="el" href="a00001.html#acd41575a35d1c5d55e955aafc9762454">btree_impl::allow_duplicates</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operational parameter: Allow duplicate keys in the btree.  <a href="#a2a11e2ee03e9bb4cb206826de0b135b2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00006.html#a8dd7ea83ed8beaba51c5578b1283e306">btree_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa78a74c628ee6ef25c5bffce7a9aacb2">tree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The contained implementation object.  <a href="#aa78a74c628ee6ef25c5bffce7a9aacb2"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_set_traits&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt;<br/>
class stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;</h3>

<p>Specialized B+ tree template class implementing STL's multiset container. </p>
<p>Implements the STL multiset using a B+ tree. It can be used as a drop-in replacement for std::multiset. Not all asymptotic time requirements are met in theory. The class has a traits class defining B+ tree properties like slots and self-verification. Furthermore an allocator can be specified for tree nodes.</p>
<p>It is somewhat inefficient to implement a multiset using a B+ tree, a plain B tree would hold fewer copies of the keys.</p>
<p>The set class is derived from the base implementation class btree by specifying an empty struct as data_type. All function are adapted to provide the inner class with placeholder objects. Most tricky to get right were the return type's of iterators which as value_type should be the same as key_type, and not a pair of key and dummy-struct. This is taken case of using some template magic in the btree class. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00064">64</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3bd75b696bde37ad47838d8058503799"></a><!-- doxytag: member="stx::btree_multiset::allocator_type" ref="a3bd75b696bde37ad47838d8058503799" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Alloc <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fourth template parameter: STL allocator. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00081">81</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8dd7ea83ed8beaba51c5578b1283e306"></a><!-- doxytag: member="stx::btree_multiset::btree_impl" ref="a8dd7ea83ed8beaba51c5578b1283e306" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00001.html">stx::btree</a>&lt;<a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <a class="el" href="a00006.html#a4797d9899509ebbd391f6478f85fefd9">data_type</a>, <a class="el" href="a00006.html#a5fe61553bb02818305fde84b5342e753">value_type</a>, <a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <a class="el" href="a00006.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, true, <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>, true&gt; <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a8dd7ea83ed8beaba51c5578b1283e306">btree_impl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation type of the btree_base. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00110">110</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac3b6e263ec2f54cab4e541b02e2156bf"></a><!-- doxytag: member="stx::btree_multiset::const_iterator" ref="ac3b6e263ec2f54cab4e541b02e2156bf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::const_iterator <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like iterator object for B+ tree items. </p>
<p>The iterator points to a specific slot number in a leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00162">162</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa137474f07b11232834fc838c96f89b4"></a><!-- doxytag: member="stx::btree_multiset::const_reverse_iterator" ref="aa137474f07b11232834fc838c96f89b4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::const_reverse_iterator <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create constant reverse iterator by using STL magic </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00168">168</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4797d9899509ebbd391f6478f85fefd9"></a><!-- doxytag: member="stx::btree_multiset::data_type" ref="a4797d9899509ebbd391f6478f85fefd9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00014.html">empty_struct</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a4797d9899509ebbd391f6478f85fefd9">data_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The empty data_type. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00100">100</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d0c6764234271152a77643d5f160889"></a><!-- doxytag: member="stx::btree_multiset::iterator" ref="a0d0c6764234271152a77643d5f160889" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::iterator <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like iterator object for B+ tree items. </p>
<p>The iterator points to a specific slot number in a leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00158">158</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4d81bc53597e88abe6617421837df21"></a><!-- doxytag: member="stx::btree_multiset::key_compare" ref="ab4d81bc53597e88abe6617421837df21" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Compare <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Second template parameter: Key comparison function object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00074">74</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="adaf86bdcdf48a7d4ed87ae020436287e"></a><!-- doxytag: member="stx::btree_multiset::key_type" ref="adaf86bdcdf48a7d4ed87ae020436287e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>First template parameter: The key type of the btree. </p>
<p>This is stored in inner nodes and leaves </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00071">71</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa20cfd7ed6236bc3c51b20d5a77a5286"></a><!-- doxytag: member="stx::btree_multiset::reverse_iterator" ref="aa20cfd7ed6236bc3c51b20d5a77a5286" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::reverse_iterator <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create mutable reverse iterator by using STL magic </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00165">165</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a99552060748673aa8a60e7d663f8f4a4"></a><!-- doxytag: member="stx::btree_multiset::self" ref="a99552060748673aa8a60e7d663f8f4a4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00006.html">btree_multiset</a>&lt;<a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <a class="el" href="a00006.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>&gt; <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef of our own type. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00106">106</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb308af84d816e44d6fcaaf075b08a22"></a><!-- doxytag: member="stx::btree_multiset::size_type" ref="acb308af84d816e44d6fcaaf075b08a22" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00001.html#aa692f5303dd2c4fee4958cbbfc3db5da">btree_impl::size_type</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size type used to count keys. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00116">116</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf34a1c10a3b0e0c1caa0358b9d4f059"></a><!-- doxytag: member="stx::btree_multiset::traits" ref="adf34a1c10a3b0e0c1caa0358b9d4f059" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Traits <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Third template parameter: Traits object used to define more parameters of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00078">78</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a268704f56c398ed05b600262f8c1d558"></a><!-- doxytag: member="stx::btree_multiset::tree_stats" ref="a268704f56c398ed05b600262f8c1d558" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::tree_stats <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Small structure containing statistics about the tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00119">119</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ef41640ce62bdd8b1857ae6c3ef1c51"></a><!-- doxytag: member="stx::btree_multiset::value_compare" ref="a7ef41640ce62bdd8b1857ae6c3ef1c51" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::value_compare <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function class comparing two value_type keys. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00113">113</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5fe61553bb02818305fde84b5342e753"></a><!-- doxytag: member="stx::btree_multiset::value_type" ref="a5fe61553bb02818305fde84b5342e753" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a5fe61553bb02818305fde84b5342e753">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the set value_type: the key_type. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00103">103</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae51979526a758ca48dff71269509d30d"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="ae51979526a758ca48dff71269509d30d" args="(const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor initializing an empty B+ tree with the standard key comparison function. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00181">181</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4411a079d52cdac10490c9f44827ed63"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="a4411a079d52cdac10490c9f44827ed63" args="(const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing an empty B+ tree with a special key comparison object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00188">188</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6dcabc7e14031cfe33c2e476b1c42e0b"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="a6dcabc7e14031cfe33c2e476b1c42e0b" args="(InputIterator first, InputIterator last, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing a B+ tree with the range [first,last) </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00196">196</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00484">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a850ad8cd4782cf8dd11ef9ec7660dbf1"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="a850ad8cd4782cf8dd11ef9ec7660dbf1" args="(InputIterator first, InputIterator last, const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing a B+ tree with the range [first,last) and a special key comparison object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00206">206</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00484">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="aec3bb61dacff05a504ae53889d8e3bf3"></a><!-- doxytag: member="stx::btree_multiset::~btree_multiset" ref="aec3bb61dacff05a504ae53889d8e3bf3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::~<a class="el" href="a00006.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees up all used B+ tree memory pages. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00214">214</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a988a8fc330955bc3e74976865c841904"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="a988a8fc330955bc3e74976865c841904" args="(const self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>The newly initialized B+ tree object will contain a copy of all keys. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00474">474</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0c8b01c05f01540fe8e7c87f7e798557"></a><!-- doxytag: member="stx::btree_multiset::begin" ref="a0c8b01c05f01540fe8e7c87f7e798557" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a0c8b01c05f01540fe8e7c87f7e798557">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00263">263</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01573">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::begin()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="acca702924e73cc5df9f8e27f59259f7c"></a><!-- doxytag: member="stx::btree_multiset::begin" ref="acca702924e73cc5df9f8e27f59259f7c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a0c8b01c05f01540fe8e7c87f7e798557">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only constant iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00277">277</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01573">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::begin()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac0ce2f8dad3a95fe6c276437abdacbc1"></a><!-- doxytag: member="stx::btree_multiset::bulk_load" ref="ac0ce2f8dad3a95fe6c276437abdacbc1" args="(Iterator first, Iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ac0ce2f8dad3a95fe6c276437abdacbc1">bulk_load</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bulk load a sorted range [first,last). </p>
<p>Loads items into leaves and constructs a B-tree above them. The tree must be empty when calling this function. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00513">513</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02401">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::bulk_load()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a77cc7f5486c5add7feb4c9e601c4d921"></a><!-- doxytag: member="stx::btree_multiset::clear" ref="a77cc7f5486c5add7feb4c9e601c4d921" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a77cc7f5486c5add7feb4c9e601c4d921">clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees all keys and all nodes of the tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00253">253</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01527">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::clear()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ae64a7de25306d48798d502de46b6c"></a><!-- doxytag: member="stx::btree_multiset::count" ref="ab2ae64a7de25306d48798d502de46b6c" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ab2ae64a7de25306d48798d502de46b6c">count</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns the number of identical key entries found. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00371">371</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01822">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::count()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="af443508ecb8fd77f32f01709f2f9d666"></a><!-- doxytag: member="stx::btree_multiset::dump" ref="af443508ecb8fd77f32f01709f2f9d666" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#af443508ecb8fd77f32f01709f2f9d666">dump</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump the contents of the B+ tree out onto an ostream as a binary image. </p>
<p>The image contains memory pointers which will be fixed when the image is restored. For this to work your key_type must be an integral type and contain no pointers or references. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00584">584</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03843">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::dump()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a1943f3a2270fd9a13deb4d98855eb4bc"></a><!-- doxytag: member="stx::btree_multiset::empty" ref="a1943f3a2270fd9a13deb4d98855eb4bc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a1943f3a2270fd9a13deb4d98855eb4bc">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there is at least one key in the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00327">327</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01734">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::empty()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a3b3fdd20ed1c32051e6e8e9762789178"></a><!-- doxytag: member="stx::btree_multiset::end" ref="a3b3fdd20ed1c32051e6e8e9762789178" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00270">270</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01580">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::end()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8fa9d5230ddb6f9306b2e941c1448ece"></a><!-- doxytag: member="stx::btree_multiset::end" ref="a8fa9d5230ddb6f9306b2e941c1448ece" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only constant iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00284">284</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01580">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::end()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a405388c6589746b4a01af6ab8a4b4321"></a><!-- doxytag: member="stx::btree_multiset::equal_range" ref="a405388c6589746b4a01af6ab8a4b4321" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>, <a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&gt; <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a405388c6589746b4a01af6ab8a4b4321">equal_range</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="a00006.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00006.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00407">407</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01940">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::equal_range()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aeffb8c7205996ac1a5ac40976f47a96f"></a><!-- doxytag: member="stx::btree_multiset::equal_range" ref="aeffb8c7205996ac1a5ac40976f47a96f" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>, <a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&gt; <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a405388c6589746b4a01af6ab8a4b4321">equal_range</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="a00006.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00006.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00413">413</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01940">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::equal_range()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="afe2a42873c3a97234668e2feabc5191d"></a><!-- doxytag: member="stx::btree_multiset::erase" ref="afe2a42873c3a97234668e2feabc5191d" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#afe2a42873c3a97234668e2feabc5191d">erase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases all the entries of the given key. </p>
<p>This is implemented using <a class="el" href="a00006.html#aa4e4cd44265e4c5fb8617ca3d17dd843" title="Erases one (the first) entry of the given key.">erase_one()</a> and thus not very efficient. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00529">529</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02619">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::erase()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac174897bad297d88927e6abe4056a3b8"></a><!-- doxytag: member="stx::btree_multiset::erase" ref="ac174897bad297d88927e6abe4056a3b8" args="(iterator iter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#afe2a42873c3a97234668e2feabc5191d">erase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase the key/data pair referenced by the iterator. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00535">535</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02619">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::erase()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aa5c867534e27a06c07baa2c17fbccfd1"></a><!-- doxytag: member="stx::btree_multiset::erase" ref="aa5c867534e27a06c07baa2c17fbccfd1" args="(iterator, iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#afe2a42873c3a97234668e2feabc5191d">erase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all keys in the range [first,last). </p>
<p>This function is currently not implemented by the B+ Tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00543">543</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4e4cd44265e4c5fb8617ca3d17dd843"></a><!-- doxytag: member="stx::btree_multiset::erase_one" ref="aa4e4cd44265e4c5fb8617ca3d17dd843" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#aa4e4cd44265e4c5fb8617ca3d17dd843">erase_one</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases one (the first) entry of the given key. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00522">522</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02596">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::erase_one()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a1438934e738862154bbcfa1314b485bb"></a><!-- doxytag: member="stx::btree_multiset::exists" ref="a1438934e738862154bbcfa1314b485bb" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a1438934e738862154bbcfa1314b485bb">exists</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-STL function checking whether a key is in the B+ tree. </p>
<p>The same as (find(k) != <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>) or (<a class="el" href="a00006.html#ab2ae64a7de25306d48798d502de46b6c" title="Tries to locate a key in the B+ tree and returns the number of identical key entries found...">count()</a> != 0). </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00350">350</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01757">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::exists()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a130a3b87e39b1d9ff8be6df80b942737"></a><!-- doxytag: member="stx::btree_multiset::find" ref="a130a3b87e39b1d9ff8be6df80b942737" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a130a3b87e39b1d9ff8be6df80b942737">find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns an iterator to the key slot if found. </p>
<p>If unsuccessful it returns <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00357">357</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01778">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::find()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac3bf82364b3392aa056b866a012ac0d8"></a><!-- doxytag: member="stx::btree_multiset::find" ref="ac3bf82364b3392aa056b866a012ac0d8" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a130a3b87e39b1d9ff8be6df80b942737">find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns an constant iterator to the key slot if found. </p>
<p>If unsuccessful it returns <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00364">364</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01778">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::find()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac2fc089101a5d6fdf86ee2d09b9eacce"></a><!-- doxytag: member="stx::btree_multiset::get_allocator" ref="ac2fc089101a5d6fdf86ee2d09b9eacce" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ac2fc089101a5d6fdf86ee2d09b9eacce">get_allocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the base node allocator provided during construction. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00244">244</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01445">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::get_allocator()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a926c5bb8fbf409b1371c1ca211ba2bde"></a><!-- doxytag: member="stx::btree_multiset::get_stats" ref="a926c5bb8fbf409b1371c1ca211ba2bde" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00006.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a>&amp; <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a926c5bb8fbf409b1371c1ca211ba2bde">get_stats</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a const reference to the current statistics. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00340">340</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01747">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::get_stats()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ad35b00f9ff7f148dbb5cfee7ac8102af"></a><!-- doxytag: member="stx::btree_multiset::insert" ref="ad35b00f9ff7f148dbb5cfee7ac8102af" args="(const key_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ad35b00f9ff7f148dbb5cfee7ac8102af">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert a key into the B+ tree. </p>
<p>As this set allows duplicates, this function never fails. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00484">484</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02106">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::insert2()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

<p>Referenced by <a class="el" href="a00032_source.html#l00196">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::btree_multiset()</a>, and <a class="el" href="a00032_source.html#l00499">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a0075140c2d21fe08b68f00e16630cff1"></a><!-- doxytag: member="stx::btree_multiset::insert" ref="a0075140c2d21fe08b68f00e16630cff1" args="(iterator hint, const key_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ad35b00f9ff7f148dbb5cfee7ac8102af">insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert a key into the B+ tree. </p>
<p>The iterator hint is currently ignored by the B+ tree insertion routine. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00491">491</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02106">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::insert2()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a75db73a6c739f8515ab508d3241feb88"></a><!-- doxytag: member="stx::btree_multiset::insert" ref="a75db73a6c739f8515ab508d3241feb88" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ad35b00f9ff7f148dbb5cfee7ac8102af">insert</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert the range [first,last) of key_type into the B+ tree. </p>
<p>Each key is inserted individually. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00499">499</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00484">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ecbf097192ab41b7a29db4349ce2d3e"></a><!-- doxytag: member="stx::btree_multiset::key_comp" ref="a3ecbf097192ab41b7a29db4349ce2d3e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a3ecbf097192ab41b7a29db4349ce2d3e">key_comp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant access to the key comparison object sorting the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00228">228</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01395">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::key_comp()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="acf1949d71f9c83184c98d084d66c56a4"></a><!-- doxytag: member="stx::btree_multiset::lower_bound" ref="acf1949d71f9c83184c98d084d66c56a4" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#acf1949d71f9c83184c98d084d66c56a4">lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns an iterator to the first pair equal to or greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00378">378</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01855">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::lower_bound()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="afb5c018e2dd2c9f53a148ddf0781921d"></a><!-- doxytag: member="stx::btree_multiset::lower_bound" ref="afb5c018e2dd2c9f53a148ddf0781921d" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#acf1949d71f9c83184c98d084d66c56a4">lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns a constant iterator to the first pair equal to or greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00386">386</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01855">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::lower_bound()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a2b0012b20d4bc04d78d1297d78550d8a"></a><!-- doxytag: member="stx::btree_multiset::max_size" ref="a2b0012b20d4bc04d78d1297d78550d8a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a2b0012b20d4bc04d78d1297d78550d8a">max_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the largest possible size of the B+ Tree. </p>
<p>This is just a function required by the STL standard, the B+ Tree can hold more items. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00334">334</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01741">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::max_size()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ae9ad03cbc3be10a4a972b06ec9abedec"></a><!-- doxytag: member="stx::btree_multiset::operator!=" ref="ae9ad03cbc3be10a4a972b06ec9abedec" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality relation. Based on operator==. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00429">429</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a2dcdf9bb9c5e2eea56e9308388b07349"></a><!-- doxytag: member="stx::btree_multiset::operator&lt;" ref="a2dcdf9bb9c5e2eea56e9308388b07349" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Total ordering relation of B+ trees of the same type. </p>
<p>It uses std::lexicographical_compare() for the actual comparison of elements. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00436">436</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a35de24d784f61ae794c1fa56fa9c6673"></a><!-- doxytag: member="stx::btree_multiset::operator&lt;=" ref="a35de24d784f61ae794c1fa56fa9c6673" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less-equal relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00448">448</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a3e8081765077002a2cbc04e20506f03d"></a><!-- doxytag: member="stx::btree_multiset::operator=" ref="a3e8081765077002a2cbc04e20506f03d" args="(const self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a>&amp; <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>*** Fast Copy: Assign Operator and Copy Constructors </p>
<p>Assignment operator. All the keys are copied </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00463">463</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8151cc2608a7a0634d5a94e3824f8e34"></a><!-- doxytag: member="stx::btree_multiset::operator==" ref="a8151cc2608a7a0634d5a94e3824f8e34" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality relation of B+ trees of the same type. </p>
<p>B+ trees of the same size and equal key (counts) are considered equal. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00423">423</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a7c85cec4d55431ea5e057602ba8fe5a0"></a><!-- doxytag: member="stx::btree_multiset::operator&gt;" ref="a7c85cec4d55431ea5e057602ba8fe5a0" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00442">442</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a603b031718fb9bb00d0edefc58d560c3"></a><!-- doxytag: member="stx::btree_multiset::operator&gt;=" ref="a603b031718fb9bb00d0edefc58d560c3" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater-equal relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00454">454</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a6aaf291909c709ea33419940352288b3"></a><!-- doxytag: member="stx::btree_multiset::print" ref="a6aaf291909c709ea33419940352288b3" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a6aaf291909c709ea33419940352288b3">print</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out the B+ tree structure with keys onto the given ostream. </p>
<p>This function requires that the header is compiled with BTREE_DEBUG and that key_type is printable via std::ostream. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00556">556</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03556">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::print()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8818ff27dd8b2275d4b6a68d728c6d77"></a><!-- doxytag: member="stx::btree_multiset::print_leaves" ref="a8818ff27dd8b2275d4b6a68d728c6d77" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a8818ff27dd8b2275d4b6a68d728c6d77">print_leaves</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out only the leaves via the double linked list. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00562">562</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03564">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::print_leaves()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ad5ff92256da155cf0a800c0be6d37f10"></a><!-- doxytag: member="stx::btree_multiset::rbegin" ref="ad5ff92256da155cf0a800c0be6d37f10" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ad5ff92256da155cf0a800c0be6d37f10">rbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00291">291</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01601">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::rbegin()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aab7bf40d95f5e2e3a6f48ff132e5aa5c"></a><!-- doxytag: member="stx::btree_multiset::rbegin" ref="aab7bf40d95f5e2e3a6f48ff132e5aa5c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ad5ff92256da155cf0a800c0be6d37f10">rbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00305">305</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01601">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::rbegin()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="accb388873e7a00b1779a27487e4c0200"></a><!-- doxytag: member="stx::btree_multiset::rend" ref="accb388873e7a00b1779a27487e4c0200" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#accb388873e7a00b1779a27487e4c0200">rend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write reverse iterator that points to the first slot in the first leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00298">298</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01608">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::rend()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a01090ac817bc6525160dbee3b2943ad1"></a><!-- doxytag: member="stx::btree_multiset::rend" ref="a01090ac817bc6525160dbee3b2943ad1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#accb388873e7a00b1779a27487e4c0200">rend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only reverse iterator that points to the first slot in the first leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00312">312</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01608">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::rend()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a7f6dd7739f76cf5d1a31507ca3d80197"></a><!-- doxytag: member="stx::btree_multiset::restore" ref="a7f6dd7739f76cf5d1a31507ca3d80197" args="(std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a7f6dd7739f76cf5d1a31507ca3d80197">restore</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restore a binary image of a dumped B+ tree from an istream. </p>
<p>The B+ tree pointers are fixed using the dump order. For dump and restore to work your key_type must be an integral type and contain no pointers or references. Returns true if the restore was successful. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00593">593</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03860">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::restore()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a9be405a164ded347358ce38599d768bd"></a><!-- doxytag: member="stx::btree_multiset::size" ref="a9be405a164ded347358ce38599d768bd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a9be405a164ded347358ce38599d768bd">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of keys in the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00321">321</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01728">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::size()</a>, and <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aad820bbc85b7beaaca43fbdb1b610b56"></a><!-- doxytag: member="stx::btree_multiset::swap" ref="aad820bbc85b7beaaca43fbdb1b610b56" args="(self &amp;from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#aad820bbc85b7beaaca43fbdb1b610b56">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00006.html#a99552060748673aa8a60e7d663f8f4a4">self</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast swapping of two identical B+ tree objects. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00219">219</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1197bbc27c927ebe4087541d601f20"></a><!-- doxytag: member="stx::btree_multiset::upper_bound" ref="a5e1197bbc27c927ebe4087541d601f20" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a5e1197bbc27c927ebe4087541d601f20">upper_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns an iterator to the first pair greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00393">393</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01898">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::upper_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a5833bec011824d4b54b716b685ae74ca"></a><!-- doxytag: member="stx::btree_multiset::upper_bound" ref="a5833bec011824d4b54b716b685ae74ca" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a5e1197bbc27c927ebe4087541d601f20">upper_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00006.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns a constant iterator to the first pair greater than key, or <a class="el" href="a00006.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00401">401</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01898">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::upper_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a84f47ce04fb5330cb2d766a105b278a2"></a><!-- doxytag: member="stx::btree_multiset::value_comp" ref="a84f47ce04fb5330cb2d766a105b278a2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a84f47ce04fb5330cb2d766a105b278a2">value_comp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant access to a constructed value_type comparison object. </p>
<p>Required by the STL </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00235">235</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01402">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::value_comp()</a>.</p>

</div>
</div>
<a class="anchor" id="a862c504ed632b8591756c45273087e5a"></a><!-- doxytag: member="stx::btree_multiset::verify" ref="a862c504ed632b8591756c45273087e5a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a862c504ed632b8591756c45273087e5a">verify</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a thorough verification of all B+ tree invariants. </p>
<p>The program aborts via <a class="el" href="a00026.html#a6ac57b9b59dae34aea28cda65b0d14bb" title="Assertion only if BTREE_DEBUG is defined. This is not used in verify().">BTREE_ASSERT()</a> if something is wrong. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00573">573</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00174">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l03630">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;::verify()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2a11e2ee03e9bb4cb206826de0b135b2"></a><!-- doxytag: member="stx::btree_multiset::allow_duplicates" ref="a2a11e2ee03e9bb4cb206826de0b135b2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a2a11e2ee03e9bb4cb206826de0b135b2">allow_duplicates</a> = <a class="el" href="a00001.html#acd41575a35d1c5d55e955aafc9762454">btree_impl::allow_duplicates</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operational parameter: Allow duplicate keys in the btree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00151">151</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f660e9d76a8bc2d8afa950dec6f8fda"></a><!-- doxytag: member="stx::btree_multiset::debug" ref="a1f660e9d76a8bc2d8afa950dec6f8fda" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a1f660e9d76a8bc2d8afa950dec6f8fda">debug</a> = <a class="el" href="a00001.html#a224f31a88d50490e14f0f291d70ef2fc">btree_impl::debug</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug parameter: Prints out lots of debug information about how the algorithms change the tree. </p>
<p>Requires the header file to be compiled with BTREE_DEBUG and the key type must be std::ostream printable. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00148">148</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a291d8f653427c2dac2870ddd1e93a326"></a><!-- doxytag: member="stx::btree_multiset::innerslotmax" ref="a291d8f653427c2dac2870ddd1e93a326" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a291d8f653427c2dac2870ddd1e93a326">innerslotmax</a> = <a class="el" href="a00001.html#a78ae296638b9d6961f9101ddf45bf3e0">btree_impl::innerslotmax</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base B+ tree parameter: The number of key slots in each inner node, this can differ from slots in each leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00129">129</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad3e346ec9ff913e6b17857f7de7fa6f0"></a><!-- doxytag: member="stx::btree_multiset::leafslotmax" ref="ad3e346ec9ff913e6b17857f7de7fa6f0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ad3e346ec9ff913e6b17857f7de7fa6f0">leafslotmax</a> = <a class="el" href="a00001.html#ac6c274f39fce8e14f6a881fc1da39cf8">btree_impl::leafslotmax</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base B+ tree parameter: The number of key/data slots in each leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00125">125</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a568261850e92855ce6dd296e969cf12d"></a><!-- doxytag: member="stx::btree_multiset::mininnerslots" ref="a568261850e92855ce6dd296e969cf12d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a568261850e92855ce6dd296e969cf12d">mininnerslots</a> = <a class="el" href="a00001.html#aefbcc95b60d5bae8dd7ba9c25e5b6654">btree_impl::mininnerslots</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computed B+ tree parameter: The minimum number of key slots used in an inner node. </p>
<p>If fewer slots are used, the inner node will be merged or slots shifted from it's siblings. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00139">139</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a52ff2314ff166b6aec7ad572d37291cf"></a><!-- doxytag: member="stx::btree_multiset::minleafslots" ref="a52ff2314ff166b6aec7ad572d37291cf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#a52ff2314ff166b6aec7ad572d37291cf">minleafslots</a> = <a class="el" href="a00001.html#ad8525611bf3b079ca4ab13dbab9b23c0">btree_impl::minleafslots</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computed B+ tree parameter: The minimum number of key slots used in a leaf. </p>
<p>If fewer slots are used, the leaf will be merged or slots shifted from it's siblings. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00134">134</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad58d175cab81f7f1947cdc54547fbf85"></a><!-- doxytag: member="stx::btree_multiset::selfverify" ref="ad58d175cab81f7f1947cdc54547fbf85" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#ad58d175cab81f7f1947cdc54547fbf85">selfverify</a> = <a class="el" href="a00001.html#a598601fa16cfb97b8b60a4eae6bde5ae">btree_impl::selfverify</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00143">143</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa78a74c628ee6ef25c5bffce7a9aacb2"></a><!-- doxytag: member="stx::btree_multiset::tree" ref="aa78a74c628ee6ef25c5bffce7a9aacb2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html#a8dd7ea83ed8beaba51c5578b1283e306">btree_impl</a> <a class="el" href="a00006.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00006.html#aa78a74c628ee6ef25c5bffce7a9aacb2">tree</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The contained implementation object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00174">174</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>Referenced by <a class="el" href="a00032_source.html#l00263">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::begin()</a>, <a class="el" href="a00032_source.html#l00513">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::bulk_load()</a>, <a class="el" href="a00032_source.html#l00253">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::clear()</a>, <a class="el" href="a00032_source.html#l00371">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::count()</a>, <a class="el" href="a00032_source.html#l00584">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::dump()</a>, <a class="el" href="a00032_source.html#l00327">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::empty()</a>, <a class="el" href="a00032_source.html#l00270">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::end()</a>, <a class="el" href="a00032_source.html#l00407">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::equal_range()</a>, <a class="el" href="a00032_source.html#l00529">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase()</a>, <a class="el" href="a00032_source.html#l00522">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase_one()</a>, <a class="el" href="a00032_source.html#l00350">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::exists()</a>, <a class="el" href="a00032_source.html#l00357">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::find()</a>, <a class="el" href="a00032_source.html#l00244">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_allocator()</a>, <a class="el" href="a00032_source.html#l00340">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_stats()</a>, <a class="el" href="a00032_source.html#l00484">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>, <a class="el" href="a00032_source.html#l00228">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::key_comp()</a>, <a class="el" href="a00032_source.html#l00378">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::lower_bound()</a>, <a class="el" href="a00032_source.html#l00334">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::max_size()</a>, <a class="el" href="a00032_source.html#l00429">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator!=()</a>, <a class="el" href="a00032_source.html#l00436">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;()</a>, <a class="el" href="a00032_source.html#l00448">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;=()</a>, <a class="el" href="a00032_source.html#l00463">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator=()</a>, <a class="el" href="a00032_source.html#l00423">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator==()</a>, <a class="el" href="a00032_source.html#l00442">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;()</a>, <a class="el" href="a00032_source.html#l00454">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;=()</a>, <a class="el" href="a00032_source.html#l00556">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::print()</a>, <a class="el" href="a00032_source.html#l00562">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::print_leaves()</a>, <a class="el" href="a00032_source.html#l00291">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::rbegin()</a>, <a class="el" href="a00032_source.html#l00298">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::rend()</a>, <a class="el" href="a00032_source.html#l00593">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::restore()</a>, <a class="el" href="a00032_source.html#l00321">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::size()</a>, <a class="el" href="a00032_source.html#l00219">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::swap()</a>, <a class="el" href="a00032_source.html#l00393">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::upper_bound()</a>, <a class="el" href="a00032_source.html#l00235">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::value_comp()</a>, and <a class="el" href="a00032_source.html#l00573">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::verify()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>stx/<a class="el" href="a00032_source.html">btree_multiset.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun May 5 2013 23:38:44 for STX B+ Tree Template Classes by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
