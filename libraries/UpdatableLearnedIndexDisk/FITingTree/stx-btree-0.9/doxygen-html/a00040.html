<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>STX B+ Tree Template Classes: Member List</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">STX B+ Tree Template Classes
   &#160;<span id="projectnumber">0.9</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00036.html">stx</a>      </li>
      <li class="navelem"><a class="el" href="a00001.html">btree</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt; Member List</div>  </div>
</div><!--header-->
<div class="contents">
This is the complete list of members for <a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a>, including all inherited members.<table>
  <tr class="memlist"><td><a class="el" href="a00001.html#a1bf04093f2dc2a1cb57955ff55d3762a">allocate_inner</a>(unsigned short level)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ab6ff4b0f13f48e417a45431318a00337">allocate_leaf</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aef567d7893cd02d22933a2e68702532b">allocator_type</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#acd41575a35d1c5d55e955aafc9762454">allow_duplicates</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a564a6ea78bcc0de0bbc1fdff65f547fd">begin</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a530d199e20aaf216b82f43a51e1c4526">begin</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ab8d4b1a025d08beb515f5e3a8033deb4">btree</a>(const allocator_type &amp;alloc=allocator_type())</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, explicit]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a6601ec01fa386f754809f62baad7a112">btree</a>(const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, explicit]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad6c89387fa35b4724f9da5cfc91033f5">btree</a>(InputIterator first, InputIterator last, const allocator_type &amp;alloc=allocator_type())</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ac7d4c03c5db5551f72d69f44471e3217">btree</a>(InputIterator first, InputIterator last, const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a34a7b277c27f485c2237bdc73888ec74">btree</a>(const btree_self &amp;other)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a971345163fcd46bfd726cb31ad5cd02ba22159386e444003f86027c412d28ef43">btree_fixmerge</a> enum value</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a971345163fcd46bfd726cb31ad5cd02ba9c5aae923574ee89980049e9088f943e">btree_not_found</a> enum value</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a971345163fcd46bfd726cb31ad5cd02bae9409a8c5c6d8b59e3fd6a70e1106d88">btree_ok</a> enum value</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad7844e40add49f90fc9e1f2c888afb14">btree_self</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a971345163fcd46bfd726cb31ad5cd02ba7e66903441bb2c3c8164040f9efea0d8">btree_update_lastkey</a> enum value</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a053c808858d78e6f0a93041ab612d656">bulk_load</a>(Iterator ibegin, Iterator iend)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aa2acf975007740100b9803fcea573036">clear</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a33241f6ae21f58c9747a6392470b646c">clear_recursive</a>(node *n)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#abf107ac5589a59a068bdc648f02bf353">copy_recursive</a>(const node *n)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a3882a2b0e2ea8eb43b4261e7f3eb32f2">count</a>(const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad8a89e088fbfedec4218ea46f8899941">data_copy</a>(InputIterator first, InputIterator last, OutputIterator result)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a555a24bfd925a5d77bba28041d207f8d">data_copy_backward</a>(InputIterator first, InputIterator last, OutputIterator result)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#acfb48ad6a3845870e64c38dd1b562616">data_type</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a224f31a88d50490e14f0f291d70ef2fc">debug</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#af26da2c6a1723bd3c98229b3670e2d28">dump</a>(std::ostream &amp;os) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad4ad2abd47967f9a7d89730bd5a0380d">dump_node</a>(std::ostream &amp;os, const node *n) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad7cf0c4833d2ea3fcd79df4c884bab40">empty</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a8f1fbaf7eabefca66188e2bf6996573d">end</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aaad45bd0825139ad9168fc4ee143fe7d">end</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ac73cf4621b0650fef2ea3ea1d2fd2f90">equal_range</a>(const key_type &amp;key)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aed04d2ca76fe26b8a103abe8d988f4af">equal_range</a>(const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a8bced926ecf575a393e06ca7d35291f1">erase</a>(const key_type &amp;key)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a405c45adc3df9f58da98a785b65078a3">erase</a>(iterator iter)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ae89ad4210d7a1f320af633818b28a9f2">erase</a>(iterator, iterator)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a28e069672d73503156b4bc604064c4ac">erase_iter_descend</a>(const iterator &amp;iter, node *curr, node *left, node *right, inner_node *leftparent, inner_node *rightparent, inner_node *parent, unsigned int parentslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a07ca3a19f1e20908f7cca3180420c817">erase_one</a>(const key_type &amp;key)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a141c007e7d7dce479b2797f3a0735d03">erase_one_descend</a>(const key_type &amp;key, node *curr, node *left, node *right, inner_node *leftparent, inner_node *rightparent, inner_node *parent, unsigned int parentslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a3c1b922d80faa7d5864237b4791a7961">exists</a>(const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a90bd85f703bb74d7ab7dc967bf8d712f">find</a>(const key_type &amp;key)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a6271881b282c78b6e17fa08de0052d5e">find</a>(const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a605361a6a2254edf8ecdffef35a85669">find_lower</a>(const node_type *n, const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a46ff197e60365a8cad59fd72f935b59c">find_upper</a>(const node_type *n, const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a1bac362a2e8585e6682d332c9b4ec583">free_node</a>(node *n)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad7b097e1a4301e319d8a7e6f6bb661fd">get_allocator</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a81c7f4e56b3421976855daf40c6e20fc">get_stats</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a583e6f3a9b61bb4b0ca9886ea52f73b9">inner_node_allocator</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a78ae296638b9d6961f9101ddf45bf3e0">innerslotmax</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a29d3aa8b03d2def35a358aebb2853053">insert</a>(const pair_type &amp;x)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a3728a56b1c508547d13420d4d2e6054c">insert</a>(const key_type &amp;key, const data_type &amp;data)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a21d7a0745168857083ca888c5539275b">insert</a>(iterator, const pair_type &amp;x)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aa72caeff37728fa324ed4ea406cee57b">insert</a>(InputIterator first, InputIterator last)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a586dd230f8be24eaeebc75cc95196d78">insert2</a>(const key_type &amp;key, const data_type &amp;data)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a255994ba0a472e0d8f13fea2951d63f9">insert2</a>(iterator, const key_type &amp;key, const data_type &amp;data)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a07898a6b8d2fcc51dc713c1096ce8fdf">insert_descend</a>(node *n, const key_type &amp;key, const data_type &amp;value, key_type *splitkey, node **splitnode)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a0ec1af7db81bf48c6542eca6a126b991">insert_start</a>(const key_type &amp;key, const data_type &amp;value)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a6200a8a00989f77f053e1200da7f816b">key_comp</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a71413b8b8a1440539691a97f4cb61cae">key_compare</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ac3b0c8e750101dfad0ef70c54532dd68">key_equal</a>(const key_type &amp;a, const key_type &amp;b) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a7846f950b879c014e9379860266ef0b5">key_greater</a>(const key_type &amp;a, const key_type &amp;b) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a7d9e621a7b8c3e88820e49874381ec1b">key_greaterequal</a>(const key_type &amp;a, const key_type b) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a6ab60bc4547d2363c0a0d1b89e1e6c32">key_less</a>(const key_type &amp;a, const key_type b) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a1a0b97590280a37b8622b000fe4d2d07">key_lessequal</a>(const key_type &amp;a, const key_type b) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a73a9d635f33527a1329937f3e5f0ee5a">key_type</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aacca4955cae12c5da0b91a020d05d42a">leaf_node_allocator</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ac6c274f39fce8e14f6a881fc1da39cf8">leafslotmax</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aa0b7c53085ef7106f3d430d850b4959e">lower_bound</a>(const key_type &amp;key)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a534f04efcbc017d34df9dfa9ad0e4047">lower_bound</a>(const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a36368c13e6be2feca3cbcc0aa8950b64">m_allocator</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a13acabf72d2c7d380bfd49fc8cb946aa">m_headleaf</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ab2994c7f5b38e618e894129e596d79d1">m_key_less</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a359f38ed7d0557cd5726ecf80f868e80">m_root</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ac1971d7f227239aae76a2a88657a31a3">m_stats</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a570d9cb259032b2ce9c5edce77afbcc7">m_tailleaf</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a3285e41cd6c4566e99d8c82803ad4d92">max_size</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ae41ed6372b1f0e7cc76d082fb7d0c18c">merge_inner</a>(inner_node *left, inner_node *right, inner_node *parent, unsigned int parentslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a8fde1571d49bf44f58f492ccad6875f9">merge_leaves</a>(leaf_node *left, leaf_node *right, inner_node *parent)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aefbcc95b60d5bae8dd7ba9c25e5b6654">mininnerslots</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad8525611bf3b079ca4ab13dbab9b23c0">minleafslots</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aa8d82a57e9d983487477fbab491fe77b">operator!=</a>(const btree_self &amp;other) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a0861b6d445c1701ef81625676b88d08f">operator&lt;</a>(const btree_self &amp;other) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a9547e921eb277c76a7c5707668bcdb3d">operator&lt;=</a>(const btree_self &amp;other) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a888dd89447d0a1ad66276c208e52f348">operator=</a>(const btree_self &amp;other)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#af0c66916cc7315b98213bb0a276ad1c5">operator==</a>(const btree_self &amp;other) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aac294ce4d54a06978bb1bd1cb6b61994">operator&gt;</a>(const btree_self &amp;other) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a820ebeacf8619198969de50fd3a406a3">operator&gt;=</a>(const btree_self &amp;other) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a76bd9fc84f712e0d962314c1d6a188ce">pair_to_value_type</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a2cddd431e50047766f45902b9f6f5c31">pair_type</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a29af931b81dc3446d1ffadab6fd5e017">print</a>(std::ostream &amp;os) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a2e9097d4266851d84d9e3813921155c6">print_leaves</a>(std::ostream &amp;os) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a7a031022658d93a4d7d92522947816b4">print_node</a>(std::ostream &amp;os, const node *node, unsigned int depth=0, bool recursive=false)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a4e2f4ba4141820f4bc5782298c261aa5">rbegin</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a6a6224c68ffa219bf9ca4f4ef229e915">rbegin</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a625d6f5e37cfed631a403fe36fa818dc">rend</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aa0536538d736bf52c94144b806bfd12f">rend</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#adf438d8a86c9784e277adfbb6ed5783d">restore</a>(std::istream &amp;is)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a90299b74161abaef68c886e2d53ad490">restore_node</a>(std::istream &amp;is)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a971345163fcd46bfd726cb31ad5cd02b">result_flags_t</a> enum name</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a598601fa16cfb97b8b60a4eae6bde5ae">selfverify</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a8abbc58dfcbb672bc1273a402b57b750">shift_left_inner</a>(inner_node *left, inner_node *right, inner_node *parent, unsigned int parentslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a11529634e6a0fd90440272d0b8caf249">shift_left_leaf</a>(leaf_node *left, leaf_node *right, inner_node *parent, unsigned int parentslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a4aebdb2c529528d5f17d14b9b0ec1f24">shift_right_inner</a>(inner_node *left, inner_node *right, inner_node *parent, unsigned int parentslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#acb8565c057e6c9923adbae0e96f51523">shift_right_leaf</a>(leaf_node *left, leaf_node *right, inner_node *parent, unsigned int parentslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private, static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a3942d7144bc93cf094b62f03e6113f4e">size</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#aa692f5303dd2c4fee4958cbbfc3db5da">size_type</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a5716fa91bd7418aed6dd62c33392e479">split_inner_node</a>(inner_node *inner, key_type *_newkey, node **_newinner, unsigned int addslot)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ac82d4e07a4397d91c9fb5b124d229fb0">split_leaf_node</a>(leaf_node *leaf, key_type *_newkey, node **_newleaf)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a2413b9b084811d786cd928df4b9fe37c">swap</a>(btree_self &amp;from)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a8b13a0eb2e558d11830d38de21b82319">traits</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a0404bb704466a149ea96613b7c5ef3e2">upper_bound</a>(const key_type &amp;key)</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a264d9835af5474e009eee3b617fa1411">upper_bound</a>(const key_type &amp;key) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a636973c0a66512d36c7aa833435ad023">used_as_set</a></td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a35152f783bc65c97504cd22d1812f673">value_comp</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ab66ffb9c9a42bea595ef23cf9dbfd8d6">value_type</a> typedef</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ad7008114b409fe53a5739a69f3b90e59">verify</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#ae89a72438aead5bbc0e2cf0b01999291">verify_leaflinks</a>() const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#a3691c46df55869209c7221844f48217c">verify_node</a>(const node *n, key_type *minkey, key_type *maxkey, tree_stats &amp;vstats) const </td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline, private]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="a00001.html#af3bb3b3b2596f973a258fefc46fe098f">~btree</a>()</td><td><a class="el" href="a00001.html">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc, _UsedAsSet &gt;</a></td><td><code> [inline]</code></td></tr>
</table></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun May 5 2013 23:38:43 for STX B+ Tree Template Classes by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
